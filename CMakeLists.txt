# Required for target_sources
cmake_minimum_required(VERSION 3.1)

# Version is set here, similar to how Linux does it in their central Makefile
#
# This will be generated by a script into a header file for the kernel
set(QUARK_VERSION_MAJOR "0")
set(QUARK_VERSION_MINOR "0")
set(QUARK_VERSION_PATCH "3")
set(QUARK_VERSION_SUFFIX "-dev")
set(QUARK_VERSION "${QUARK_VERSION_MAJOR}.${QUARK_VERSION_MINOR}.${QUARK_VERSION_PATCH}${QUARK_VERSION_SUFFIX}")

# Block in-source builds to prevent cluttering up the source directory
if("${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
    message(FATAL_ERROR "In-source builds are not allowed.")
endif("${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")

# Targeting baremetal so we need a generic system.
#
# Setting something like Linux or a real system name causes CMake to inject
# additional flags that break builds
set(CMAKE_SYSTEM_NAME       Generic)
set(CMAKE_SYSTEM_VERSION    1)

# Enable NASM to compile ASM files
enable_language(ASM_NASM)

# Default architecture is x86_64
set(ARCH "x86_64" CACHE STRING "Architecture to build for")
message(STATUS "Architecture: " ${ARCH})

# Some architectures (x86_64 and i686 for example) share the same source
# directory, so we need to respect that configuration. They will internally
# select the correct code when necessary based on the ARCH variable
set(SRC_ARCH ${ARCH})
if (SRC_ARCH STREQUAL "x86_64" OR SRC_ARCH STREQUAL "i686")
    set(SRC_ARCH "x86")
endif()
message(STATUS "Source architecture: " ${SRC_ARCH})

# Check if the architecture folder exists
set(ARCH_PATH "${CMAKE_SOURCE_DIR}/arch/${SRC_ARCH}")
if(NOT EXISTS ${ARCH_PATH})
    message(FATAL_ERROR "Unable to locate architecture directory. Perhaps your ARCH is wrong?")
endif()
message(STATUS "Architecture folder: " ${ARCH_PATH})

# Check if the architecture include folder exists
set(ARCH_INCLUDE_PATH "${CMAKE_SOURCE_DIR}/arch/include/${SRC_ARCH}")
if(NOT EXISTS ${ARCH_INCLUDE_PATH})
    message(FATAL_ERROR "Unable to locate architecture include directory. Perhaps your ARCH is wrong?")
endif()
message(STATUS "Architecture include folder: " ${ARCH_INCLUDE_PATH})

# Check if the architecture platform file exists. The platform files contains
# additional CXXFLAGS, LDFLAGS, etc.
#
# Note that they aren't included yet, we just check that they exist.
if(NOT DEFINED ${PLATFORM_FILE})
    set(PLATFORM_FILE ${ARCH_PATH}/platform.cmake)
endif()
if(NOT EXISTS ${PLATFORM_FILE})
    message(FATAL_ERROR "Platform file does not exist: " ${PLATFORM_FILE})
endif()
message(STATUS "Platform file: " ${PLATFORM_FILE})

# Verify that the sysroot exists. We will install the kernel into the /boot
# directory in the sysroot
if(NOT DEFINED SYSROOT)
    set(SYSROOT "${CMAKE_SOURCE_DIR}/../hdd")
endif()
message(STATUS "Sysroot: " ${SYSROOT})

# Verify that the compiler exists
#
# CMake will conduct additional checks that it actually works
find_program(CMAKE_CXX_COMPILER ${ARCH}-pepper-g++)
if(NOT CMAKE_CXX_COMPILER)
    message(FATAL_ERROR "Compiler not found! Run the \
                         toolchain script in Pepper to build a toolchain. If \
                         you have already built it, make sure that you have run \
                         envsetup.sh before configuring CMake.")
endif()
message(STATUS "CXX Compiler: " ${CMAKE_CXX_COMPILER})

# Declare our project as a C++ project
project(Quark CXX)

include(${PLATFORM_FILE})

# We want C++11
set(CMAKE_CXX_STANDARD 11)

# We must build with -fno-rtti and -fno-exceptions because they require a support library
#
# -fdiagnostics-color=always is required for color output because GCC disables
# them otherwise as it assumes that we are piping the output
#
# -Wno-missing-field-initializers is necessary to shut up GCC about things like
# initializing a struct with stuff like {} or {0}
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wno-missing-field-initializers -ffreestanding -fno-builtin -fno-rtti -fno-exceptions -fno-stack-protector -fdiagnostics-color=always")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -O0 -g -DQUARK_DEBUG")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -DQUARK_RELEASE")
message(STATUS "CXXFLAGS: " ${CMAKE_CXX_FLAGS})

# -nostdlib disables linking with crt*.o files and the standard library
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -nostdlib")
message(STATUS "LDFLAGS: " ${CMAKE_EXE_LINKER_FLAGS})

# Set the kernel include directory as a search path
set(INCLUDE_DIRS "${INCLUDE_DIRS} ${CMAKE_SOURCE_DIR}/include/")
include_directories(${INCLUDE_DIRS})
message(STATUS "Include directories: " ${INCLUDE_DIRS})

# Command to create symlink from architecture include to include/arch so
# the kernel can include arch files under arch/* instead of having to know
# what architecture is being built.
#
# We need to set it into a variable instead of directly passing it to execute_process
# because CMake parses strings weird
set(CREATE_ARCH_SYMLINK ${CMAKE_COMMAND} -E create_symlink ${ARCH_INCLUDE_PATH} ${CMAKE_SOURCE_DIR}/include/arch)
execute_process(
    COMMAND ${CREATE_ARCH_SYMLINK}
)

# A custom command to generate the version header from the version variables
# we set in the beginning
add_custom_command(
    OUTPUT ${CMAKE_SOURCE_DIR}/include/kernel/version.h
    COMMAND ${CMAKE_SOURCE_DIR}/tools/version.sh
        ${QUARK_VERSION}
        ${ARCH}
        ${CMAKE_CXX_COMPILER}
    COMMENT "Generating version header"
)

# Add quark.kernel with version.h as a dependency so it will get built
add_executable(quark.kernel ${CMAKE_SOURCE_DIR}/include/kernel/version.h)
add_subdirectory(${ARCH_PATH})
add_subdirectory(cpu)
add_subdirectory(drivers)
add_subdirectory(fs)
add_subdirectory(kernel)
add_subdirectory(lib)
add_subdirectory(mm)
add_subdirectory(proc)

install(TARGETS quark.kernel DESTINATION "${SYSROOT}/boot")

# Ensure that quark.kernel links with libgcc for certain things like 64-bit
# arithmetic on 32-bit platforms.
target_link_libraries(quark.kernel gcc)

# Process the configuration file and generate it into a C header
configure_file(config.h.in ${CMAKE_SOURCE_DIR}/include/config.h @ONLY)
